\chapter{Implementierung der Sicherheitsl\"ucke}
\label{chap:5}

Die in \cref{chap:4} beschriebene Sicherheitslücke und das 5G-AKA Protokoll wurde nun implementiert.
Die Implementierung ist dieser Arbeit beigefügt und kann auf Github unter folgendem Link eingesehen werden: \url{}//TODO
In diesem Kapitel wird sich auf den Commit \#ID gezogen.//TODO

Es wurde das 5G-AKA Protokoll aus der Spezifikation TS 33.501 des 3GPP mit der Version V15.34.1 implementiert.
Die Sicherheitslücke wurde darauf aufbauend implementiert.


\section{Ausführen des Programms}
Zum Ausführen des Programms wurde ein \textit{Gradle} Build Script bereitgestellt.
Es wird daher empfohlen die neueste Java und Gradle Version auf einem Linux Betriebssystem installiert zu haben.

Um das Programm auszuführen muss der Befehl \lstinline{gradle run} in eine Konsole eingegeben werden.
Dafür sollte man sich in dem Ordner befinden, in dem sich auch die build.gradle Datei befindet.

Alternativ kann auch der Gradle Wrapper ausgeführt werden.
Dafür muss auf Linux oder macOS der Befehl \lstinline{./gradlew run} und auf Windows der Befehl \lstinline{gradlew.bat run} ausgeführt werden.
Auch hier sollte man sich in dem Ordner befinden, in dem sich auch die build.gradle Datei befindet.

\subsection{Einstellungen}

Das Programm erlaubt es Einstellungen anzupassen, die das Verhalten des Programms beeinflussen.
Diese Einstellungen sind in der \lstinline{Implementation.App} Klasse zu finden und lassen sich folgendermaßen beschreiben:

\subsubsection{RUN\_MODE}
Der \textit{RUN\_MODE} beschreibt ob das Protokoll oder die Sicherheitslücke simuliert werden soll.
Er kann die Werte \lstinline{RunMode.Protocol} und \lstinline{RunMode.Vulnerability} annehmen.

Wird der \textit{RUN\_MODE} auf den Wert \lstinline{RunMode.Protocol} gesetzt, dann wird ein erfolgreicher normaler Durchlauf des Protokolls simuliert. 
Nach dem Durchlauf des Protokolls wird ausgegeben ob der Durchlauf erfolgreich war.

Wird der \textit{RUN\_MODE} auf den Wert \lstinline{RunMode.Vulnerability} gesetzt, dann wird der Angriff, wie er in \cref{chap:4} beschrieben ist, simuliert.
Nach dem Durchlauf wird ausgegeben ob Authentifizierung und Angriff erfolgreich waren.
Der Angriff kann nur erfolgreich sein wenn der Langzeitschlüssel \gls{k-seaf} bei dem \gls{ue} und der \gls{seaf} Entitäten gleich ist.
Mit der \textit{DETAILED\_AUTH\_INFO} Einstellung lassen sich die Langzeitschüssel auf der Konsole ausgeben.

\subsubsection{LOG\_MESSAGES}

Mit \textit{LOG\_MESSAGES} lässt sich einstellen ob die von Entitäten empfangenen Nachrichten auf der Konsole ausgegeben werden sollen.
Es können die Werte \lstinline{true} und \lstinline{false} angegeben werden.

Wird \textit{LOG\_MESSAGES} auf \lstinline{true} gesetzt, dann werden auf der Konsole alle Nachrichten ausgeben, die von einer der Entitäten empfangen wurden.
Die Ausgabe auf der Konsole hat das Format: \textit{SENDER -> EMPFÄNGER : NACHRICHT}

Wird \textit{LOG\_MESSAGES} auf \lstinline{false} gesetzt, dann werden die empfangenen Nachrichten nicht auf der Konsole ausgegeben.

\subsubsection{DETAILED\_AUTH\_INFO}

Mit \textit{DETAILED\_AUTH\_INFO} lässt sich einstellen ob detaillierte Informationen auf der Konsole ausgegeben werden sollen.
Es können die Werte \lstinline{true} und \lstinline{false} angegeben werden.

Wird \textit{DETAILED\_AUTH\_INFO} auf \lstinline{true} gesetzt, dann werden detaillierte Informationen zur Authentifizierung auf der Konsole ausgegeben.
Dies beinhaltet Informationen darüber ob die Authentifizierung von der \gls{seaf}, der \gls{ausf} und dem \gls{udm} als erfolgreich angesehen wird, wie es in \textit{Schritt 14 \& 16} von \cref{fig:protocol_v1} beschrieben ist.
Des Weiteren wird der Langzeitschlüssel \gls{k-seaf} der im \gls{ue} und in der \gls{seaf} gespeichert ist ausgegeben.

Wird \textit{DETAILED\_AUTH\_INFO} auf \lstinline{false} gesetzt, dann werden keine detaillierten Informationen zur Authentifizierung auf der Konsole ausgegeben.


\section{Beschreibung des Aufbaus}
Für die Implementierung wurde die Programmiersprache Java gewählt.

Der Einstiegspunkt des Programms ist die \lstinline{Implementation.App} Klasse. Von dort lässt sich das Programm mit der \lstinline{main} Methode aufrufen.

In dem \lstinline{Implementation.structure} Package wird die grundlegende Struktur für Entitäten und Nachrichten definiert.
Alle Entitäten haben die \lstinline{Implementation.structure.Entity} Klasse als Superklasse und alle Nachrichten haben das \lstinline{Implementation.structure.Message} Interface implementiert.

Das \lstinline{Implementation.helper} Package beinhaltet Helferklassen.
Diese Helferklassen werden verwendet um die Übersichtlichkeit in den anderen Packages zu verbessern.
Sie beinhalten nur statische Methoden.

In dem \lstinline{Implementation.protocol} Package ist die tatsächliche Implementierung des Protokolls zu finden.
Es ist unterteilt in die Packages \lstinline{Implementation.protocol.additional}, \lstinline{Implementation.protocol.data}, \lstinline{Implementation.protocol.entities} und \lstinline{Implementation.protocol.messages}.

Das \lstinline{Implementation.protocol.additional} Package beinhaltet hauptsächlich Klassen die kryptographischen Berechnungen ausführen, wie die \gls{kdf}.
Alle Klassen in diesem Package beinhalten nur statische Methoden.

Das \lstinline{Implementation.protocol.data} Package beinhaltet Klassen, die mehrere verschiedene Parameter in sich zusammenfassen, wie z.B. der \gls{5g-he-av}.

In dem \lstinline{Implementation.protocol.entities} Package ist die Implementierung der vier Entitäten \gls{ue}, \gls{seaf}, \gls{ausf} und \gls{udm} zu finden, so wie eine \lstinline{EvilUE} Klasse, die den Angreifer darstellen soll.
In diesen Klassen ist das Versenden und Antworten auf Nachrichten implementiert.
Dies geschieht über die \lstinline{Implementation.structure.Entity} Superklasse.

In dem \lstinline{Implementation.protocol.messages} Package sind alle Nachrichten zu finden, die die Entitäten untereinander verschicken.
Jede Nachricht hat eine eigene Klasse, die das \lstinline{Implementation.structure.Message} Interface implementiert.

\subsection{Implementierung der Race Condition}


\subsection{Unterschiede zum Protokoll}
Ziel dieser Implementierung ist es die Praktikabilität der in \cref{chap:4} beschriebenen Sicherheitslücke herauszufinden.
In der Implementierung wurde daher einige Teile der Protokolls, die für die Sicherheitslücke nicht relevant sind, verändert oder weggelassen.
Nachfolgend ist eine Liste aller Abweichungen vom Protokoll aufgeführt.
Alle Abweichungen sind im Code mit dem Kommentar \lstinline{//MARK: Deviation #} versehen.
Das \lstinline{#} entspricht der Nummer der Abweichung.

\begin{enumerate}
\item //TODO: Continue
//TODO: Den Codekommentar MARK: Deviation \# setzen
\end{enumerate}

\section{Übersicht der Komponenten}
